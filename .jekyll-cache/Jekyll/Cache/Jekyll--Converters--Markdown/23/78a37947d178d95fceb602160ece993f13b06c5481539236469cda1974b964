I"(<h1 id="pincacheæºç é˜…è¯»">PINCacheæºç é˜…è¯»</h1>

<h2 id="overview">Overview</h2>

<p><em>PINCache</em> <a href="https://github.com/pinterest/PINCache.git">https://github.com/pinterest/PINCache.git</a></p>

<p><strong>PINCache</strong>æ˜¯å¯¹<strong>TMCache</strong>çš„ä¸€ä¸ªfork,ä¸»è¦ä¿®å¤äº†å…¶ä¸­çš„çº¿ç¨‹å®‰å…¨é—®é¢˜ã€‚
åœ¨é˜…è¯»æºç çš„è¿‡ç¨‹ä¸­ï¼Œå‘ç°PINCacheä½¿ç”¨äº†é”®å€¼å­˜å–æŠ€æœ¯ï¼Œå¹¶ä¸”è‡ªå·±ç»´æŠ¤äº†ä¸€ç»„å¤šçº¿ç¨‹å¹¶å‘ï¼Œä¸‹é¢ä¼šä»è¿™ä¸¤ä¸ªæ–¹é¢åˆ†ææºç ï¼Œæœ€åä»‹ç»PINCacheæš´éœ²å‡ºçš„ä¸»æ¥å£ã€‚</p>

<h2 id="ä¸‹æ ‡å­˜å–ojbect-subscriping">ä¸‹æ ‡å­˜å–ï¼ˆOjbect subscripingï¼‰</h2>

<p>åœ¨å¼€å‘è¿‡ç¨‹ä¸­æˆ‘ä»¬å¸¸å¸¸ä¼šå†™å‡ºä¸‹é¢çš„ä»£ç ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NSArray *array = @[1,2,3];
NSNubmer *one = array[1]; // 1

NSDictioanry *friend = @{@"li":@"han", @"zhang":@"xiao"};
NSString *li = name[@"li"] //@"han"
</code></pre></div></div>
<p>å¯¹NSArray, NSDictionaryçš„å¯¹è±¡ä½¿ç”¨äº†<code class="language-plaintext highlighter-rouge">[]</code>ç›´æ¥å­˜å–ï¼Œè¿™ç§å­˜å–æ–¹å¼å°±å«åš<strong>Object Subscriping</strong>.</p>

<p>Clang6æ”¯æŒä¸¤ç±»subscriptingè®¿é—®ï¼Œ array-style(æ•´æ•°è®¿é—®) ,dictionary-styleï¼ˆå¯¹è±¡è®¿é—®ï¼‰ï¼Œå½“ä½¿ç”¨ä¸‹æ ‡è®¿é—®æ—¶ï¼Œä¼šè°ƒç”¨å¯¹åº”çš„æ–¹æ³•ï¼Œä¸€ä¸ªç±»å¯ä»¥åŒæ—¶æ”¯æŒæ•´æ•°/å¯¹è±¡ä¸‹æ ‡è®¿é—®ã€‚</p>

<p>æ•´æ•°ä¸‹æ ‡è®¿é—®éœ€è¦å£°æ˜å¹¶å®ç° æ•´æ•°è®¿é—®æ”¯æŒå…¨éƒ¨æ­£è´Ÿæ•´æ•°</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- (nullable id)objectAtIndexedSubscript:(NSInteger)number
- (void)setObject:(id)object atIndexedSubscript:(NSInteger)number  
</code></pre></div></div>

<p>å­—å…¸ä¸‹æ ‡è®¿é—®å¯¹åº”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- (nullable id)objectForKeyedSubscript:(id)subscript
- (void)setObject::(id)object forKeyedSubscript:(id)subscript 
</code></pre></div></div>

<p><strong>PINCache</strong>å®šä¹‰äº†PINCacheObjectSubscriptingåè®®(å£°æ˜äº†å­—å…¸ä¸‹æ ‡è®¿é—®æ¥å£)ï¼Œé€šè¿‡è®©PINCache/PINMemoryCache/PINDiskCacheæœä»å¹¶å®ç°è¯¥åè®®å®ç°äº†ä¸‹æ ‡è®¿é—®ã€‚</p>

<h2 id="å¤šçº¿ç¨‹å¤„ç†">å¤šçº¿ç¨‹å¤„ç†</h2>

<p>ä¸ºäº†æ›´é«˜æ•ˆçš„å­˜å–æ•°æ®ï¼ŒPINCacheæä¾›äº†å¼‚æ­¥è®¿é—®æ¥å£ï¼Œå¹¶ç»´æŠ¤äº†ä¸€å¥—çº¿ç¨‹å¤„ç†ç±»ã€‚</p>

<h3 id="pinoperationqueue">PINOperationQueue</h3>
<p>å®ç°äº†ä¸€ä¸ªç±»ä¼¼äºç³»ç»Ÿé˜Ÿåˆ—çš„ç±»ï¼Œé¡ºåºå¤„ç†æ”¾è¿›å»çš„æ“ä½œ
ä¿è¯åœ¨ä¸è®¾ç½®å¹¶è¡Œå˜é‡çš„æƒ…å†µä¸‹ï¼Œé¡ºåºæ‰§è¡Œï¼Œå¦åˆ™å¹¶è¡Œæ‰§è¡Œã€‚
ä¸»è¦æ“ä½œæœ‰:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- (id &lt;PINOperationReference&gt;)addOperation:(dispatch_block_t)operation; //è¡¨ç¤ºåœ¨å½“å‰queueé‡Œæ·»åŠ ä¸€ä¸ªæ“ä½œ

- (id &lt;PINOperationReference&gt;)addOperation:(dispatch_block_t)block withPriority:(PINOperationQueuePriority)priority
{
  PINOperation *operation = [PINOperation operationWithBlock:^(id data) { block(); } //æ ¹æ®ä¼ å…¥çš„blockç”Ÿæˆä¸€ä¸ªoperationå¯¹è±¡ï¼ˆåŒ…å«åŠ¨ä½œæœ¬èº«ï¼Œä¼˜å…ˆçº§ï¼Œreference
                                                   reference:[self nextOperationReference]
                                                    priority:priority
                                                  identifier:nil
                                                        data:nil
                                                  completion:nil];
  [self lock];
    [self locked_addOperation:operation]; //æŠŠè¿™ä¸ªæ“ä½œæ·»åŠ åˆ°å…¨å±€æ“ä½œé˜Ÿåˆ—å’Œå¯¹åº”ä¼˜å…ˆçº§çš„é˜Ÿåˆ—ä¸­
  [self unlock];
  
  [self scheduleNextOperations:NO]; //æ‰§è¡Œæ“ä½œï¼Œå…·ä½“å¦‚ä¸‹
  
  return operation.reference;
}
ï¼‰

- (void)scheduleNextOperations:(BOOL)onlyCheckSerial
{
  [self lock];
  
    //get next available operation in order, ignoring priority and run it on the serial queue
    if (_serialQueueBusy == NO) {
      PINOperation *operation = [self locked_nextOperationByQueue]; //åœ¨_queuedOperationsé˜Ÿåˆ—ä¸­å–å‡ºç¬¬ä¸€ä¸ªoperationï¼Œå¹¶ä»_queuedOperationsé˜Ÿåˆ—åŠä¼˜å…ˆçº§é˜Ÿåˆ—ç§»é™¤è¯¥æ“ä½œ
      if (operation) {
        _serialQueueBusy = YES; //æ ‡å¿—æ­£åœ¨å¾€ä¸²è¡Œqueueä¸­æ”¾å…¥ä»»åŠ¡
        dispatch_async(_serialQueue, ^{
          operation.block(operation.data); //æ‰§è¡Œä¼ å…¥çš„block
          for (dispatch_block_t completion in operation.completions) {
            completion();
          }
          dispatch_group_leave(_group);
          
          [self lock];
            _serialQueueBusy = NO;
          [self unlock];
          
          //see if there are any other operations
          [self scheduleNextOperations:YES]; // ç»§ç»­å–å‡ºæ‰€æœ‰åœ¨_queuedOperationsä¸­çš„ä»»åŠ¡ï¼ˆæ„Ÿè§‰å¹¶æ²¡æœ‰å¿…è¦ï¼Œå› ä¸ºæ¯•ç«Ÿä¸€æ¬¡åªèƒ½æ”¾å…¥ä¸€ä¸ªä»»åŠ¡å•Šï¼‰
        });
      }
    }
  
  NSInteger maxConcurrentOperations = _maxConcurrentOperations;
  
  [self unlock];
  
  if (onlyCheckSerial) {
    return;
  }

  //if only one concurrent operation is set, let's just use the serial queue for executing it
  if (maxConcurrentOperations &lt; 2) { //çœ‹çœ‹æ˜¯ä¸æ˜¯å…è®¸å¹¶å‘æ‰§è¡Œï¼Œ
    return;
  }
  //å½“å‰ä¸€ä¸ªä»»åŠ¡è¿˜æ²¡æ‰§è¡Œå®Œï¼Œåˆæ”¾å…¥äº†æ–°ä»»åŠ¡æ—¶ï¼Œå…è®¸å¹¶å‘æ‰§è¡Œ
  dispatch_async(_semaphoreQueue, ^{
    dispatch_semaphore_wait(_concurrentSemaphore, DISPATCH_TIME_FOREVER);//å¹¶å‘ä»»åŠ¡æ•°ç”±_concurrentSemaphoreå†³å®š
    [self lock]; //é˜²æ­¢ä¸€ä¸ªoperationè¢«å¤šæ¬¡å–å‡º
      PINOperation *operation = [self locked_nextOperationByPriority]; //æŒ‰ä¼˜å…ˆçº§å–å‡ºä¼˜å…ˆçº§æœ€é«˜çš„ä»»åŠ¡
    [self unlock];
  
    if (operation) {
      dispatch_async(_concurrentQueue, ^{
        operation.block(operation.data);
        for (dispatch_block_t completion in operation.completions) {
          completion();
        }
        dispatch_group_leave(_group);
        dispatch_semaphore_signal(_concurrentSemaphore);
      });
    } else {
      dispatch_semaphore_signal(_concurrentSemaphore);
    }
  });
}

</code></pre></div></div>

<h3 id="pinoperationgroup">PINOperationGroup</h3>

<p>æ”¯æŒaddOperationæ·»åŠ æ“ä½œè¿›Group,å¹¶start,æ‰§è¡Œæ‰€æœ‰block,å¦‚æœæœ‰completionå›è°ƒæ—¶ï¼Œä¼šåœ¨æ‰€æœ‰ä»»åŠ¡æ‰§è¡Œå®Œä¹‹åå›è°ƒè¯¥å‡½æ•°ã€‚
è¿™ä¸ªç±»çœ‹èµ·æ¥å’Œç³»ç»Ÿæä¾›çš„groupæ²¡æœ‰å¤ªå¤§åŒºåˆ«ï¼Œä¸å¤ªæ¸…æ¥šä¸ºä»€ä¹ˆè¦è‡ªå·±å®šåˆ¶ã€‚</p>

<h2 id="ç¼“å­˜ç±»">ç¼“å­˜ç±»</h2>

<p>ç¼“å­˜ç±»æœ‰PINCache/PINMemoryCache/PINDiskCache å¹¶æ— ç»§æ‰¿å…³ç³»</p>

<h3 id="pincache">PINCache</h3>

<p>PINCacheä¸­åŒ…å«äº†PINMemoryCacheï¼ŒPINDiskCacheï¼Œæ‰§è¡Œå°†å†…å­˜ç¼“å­˜å¼‚æ­¥åŒæ­¥åˆ°ç¡¬ç›˜ç¼“å­˜çš„æ“ä½œï¼Œå¦‚ä¸‹</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//å¼‚æ­¥è¯»å–
- (void)objectForKeyAsync:(NSString *)key completion:(PINCacheObjectBlock)block
{
    if (!key || !block)
        return;
    
    __weak PINCache *weakSelf = self;
    
    [self.operationQueue addOperation:^{
        PINCache *strongSelf = weakSelf;
        if (!strongSelf)
            return;
        [strongSelf-&gt;_memoryCache objectForKeyAsync:key completion:^(PINMemoryCache *memoryCache, NSString *memoryCacheKey, id memoryCacheObject) {//ä¼˜å…ˆæŸ¥æ‰¾å†…å­˜ç¼“å­˜
            PINCache *strongSelf = weakSelf;
            if (!strongSelf)
                return;
            
            if (memoryCacheObject) {
                // Update file modification date. TODO: make this a separate method?
                [strongSelf-&gt;_diskCache fileURLForKeyAsync:memoryCacheKey completion:^(NSString * _Nonnull key, NSURL * _Nullable fileURL) {}];//å¦‚æœå­˜åœ¨å†…å­˜ç¼“å­˜ï¼Œæ›´æ–°ä¸‹é—®ä»·ç¼“å­˜çš„è®¿é—®æ—¶é—´
                [strongSelf-&gt;_operationQueue addOperation:^{
                    PINCache *strongSelf = weakSelf;
                    if (strongSelf)
                        block(strongSelf, memoryCacheKey, memoryCacheObject);
                }];
            } else {
                [strongSelf-&gt;_diskCache objectForKeyAsync:memoryCacheKey completion:^(PINDiskCache *diskCache, NSString *diskCacheKey, id &lt;NSCoding&gt; diskCacheObject) {//ä¸å­˜åœ¨ç¡¬ç›˜ç¼“å­˜ï¼Œä»ç¡¬ç›˜ç¼“å­˜ä¸­è¯»å–ï¼Œ
                    PINCache *strongSelf = weakSelf;
                    if (!strongSelf)
                        return;
                    
                    [strongSelf-&gt;_memoryCache setObjectAsync:diskCacheObject forKey:diskCacheKey completion:nil]; //æ›´ç»†å†…å­˜ç¼“å­˜
                    
                    [strongSelf-&gt;_operationQueue addOperation:^{
                        PINCache *strongSelf = weakSelf;
                        if (strongSelf)
                            block(strongSelf, diskCacheKey, diskCacheObject); //å›è°ƒ
                    }];
                }];
            }
        }];
    }];
}
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//å¼‚æ­¥è®¾ç½®
- (void)setObjectAsync:(id &lt;NSCoding&gt;)object forKey:(NSString *)key withCost:(NSUInteger)cost completion:(PINCacheObjectBlock)block
{
    if (!key || !object)
        return;
  
    PINOperationGroup *group = [PINOperationGroup asyncOperationGroupWithQueue:_operationQueue]; //ç”Ÿæˆæ“ä½œç»„
    
    [group addOperation:^{
        [_memoryCache setObject:object forKey:key withCost:cost]; //è®¾ç½®å†…å­˜ç¼“å­˜
    }];
    [group addOperation:^{
        [_diskCache setObject:object forKey:key]; //è®¾ç½®ç¡¬ç›˜ç¼“å­˜
    }];
  
    if (block) {
        [group setCompletion:^{
            block(self, key, object); //è®¾ç½®å®Œæ¯•åå›è°ƒ
        }];
    }
    
    [group start];
}
</code></pre></div></div>

<h3 id="pinmemorycache">PINMemoryCache</h3>

<p>æ”¯æŒä¸‹æ ‡å­˜å–ï¼Œæä¾›å£°æ˜å‘¨æœŸçš„å„ç§å›è°ƒæ–¹æ³•ï¼Œæä¾›å¼‚æ­¥å­˜å–æ–¹æ³•ï¼ŒæŒæœ‰ä¸€ä¸ªPINOperationqueueä¿å­˜ï¼Œç§»é™¤é”®å€¼å¯¹æ—¶ï¼Œå‘Queueä¸­æ·»åŠ ä¸€ä¸ªå¯¹åº”çš„operationï¼ˆè¿™æ€ä¹ˆä¿è¯çº¿ç¨‹å®‰å…¨ï¼Ÿï¼‰</p>

<h3 id="pindiskcache">PINDiskCache</h3>

<p>diskCacheæ“ä½œå’ŒMemoryCacheç±»ä¼¼ï¼Œä¸è¿‡æ“ä½œå¯¹è±¡å˜æˆäº†æ–‡ä»¶ï¼Œæ¯ä¸ªkeyå¯¹åº”ä¸€ä¸ªæ–‡ä»¶è·¯å¾„ï¼ˆä½¿ç”¨NSKeydArchiveråºåˆ—åŒ–å¯¹è±¡ï¼‰</p>

<h2 id="ref">Ref</h2>

<p><a href="http://clang.llvm.org/docs/ObjectiveCLiterals.html">http://clang.llvm.org/docs/ObjectiveCLiterals.html</a></p>

:ET