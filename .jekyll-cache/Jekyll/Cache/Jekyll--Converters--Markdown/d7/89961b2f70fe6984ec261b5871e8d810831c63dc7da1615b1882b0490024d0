I"ô<h1 id="runtimeä¸­çš„æ•°æ®ç»“æ„">Runtimeä¸­çš„æ•°æ®ç»“æ„</h1>

<h2 id="stripedmapobjc-privateh">StripedMap(objc-private.h)</h2>
<p>åœ¨synchronized ,ARCçš„å®ç°ä¸­éƒ½ç”¨åˆ°äº†è¿™ä¸ªç»“æ„
SrtipedMapæ˜¯ä¸€ç§æ ¹æ®ä¼ å…¥æŒ‡é’ˆå°†å¯¹è±¡æ˜ å°„åˆ°æ•°ç»„ä¸åŒä½ç½®çš„HashMapã€‚
å…¶ä¸­æ˜ å°„ç®—æ³•ä¸ºï¼š å³ç§»4ä½ &amp; å³ç§» 9ä½ æ¨¡8 ï¼ˆåµŒå…¥å¼ç³»ç»Ÿï¼‰</p>

<p>StripedMap æœ€ç‰¹åˆ«çš„ä¸€ç‚¹æ˜¯é’ˆå¯¹CPUç¼“å­˜è¿›è¡Œäº†ä¼˜åŒ–ï¼Œåœ¨macç³»ç»Ÿä¸Šï¼ŒCPU line çš„å¤§å°ä¸€èˆ¬æ˜¯64bytes,</p>

<p>è€ŒPaddedTç±»å‹æ˜¯å°†æ¨¡æ¿ç±»å‹ä»¥64byteså¯¹é½åçš„ç»“æ„ï¼Œè¿™å°±ä¿è¯äº†æ¯ä¸ªå¯¹è±¡éƒ½æœ‰ç‹¬ç«‹çš„CPUç¼“å­˜å•å…ƒï¼Œå­˜å…¥arrayçš„å¯¹è±¡ä¹‹é—´ä¸ä¼šå› ä¸ºå¦å¤–å¯¹è±¡çš„ä¿®æ”¹éœ€è¦è¯»å–å†…å­˜ï¼Œè€Œæ˜¯å¯ä»¥ç›´æ¥è¯»å–CPUç¼“å­˜ï¼Œæé«˜è¯»å†™é€Ÿåº¦ã€‚</p>

<p>ä»¥ä¸‹æ˜¯StripedMapæºç ï¼Œç•™ä¸‹äº†å…³é”®éƒ¨åˆ†ã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// StripedMap&lt;T&gt; is a map of void* -&gt; T, sized appropriately
// for cache-friendly lock striping.
// For example, this may be used as StripedMap&lt;spinlock_t&gt;
// or as StripedMap&lt;SomeStruct&gt; where SomeStruct stores a spin lock.
template&lt;typename T&gt;
class StripedMap {

    enum { CacheLineSize = 64 };

#if TARGET_OS_EMBEDDED
    enum { StripeCount = 8 };
#else
    enum { StripeCount = 64 };
#endif

    struct PaddedT {
        T value alignas(CacheLineSize);
    };

    PaddedT array[StripeCount];

    static unsigned int indexForPointer(const void *p) {
        uintptr_t addr = reinterpret_cast&lt;uintptr_t&gt;(p);
        return ((addr &gt;&gt; 4) ^ (addr &gt;&gt; 9)) % StripeCount;
    }

 public:
    T&amp; operator[] (const void *p) {
        return array[indexForPointer(p)].value;
    }
    const T&amp; operator[] (const void *p) const {
        return const_cast&lt;StripedMap&lt;T&gt;&gt;(this)[p];
    }

};

</code></pre></div></div>

<p>è€ŒStripedMap,é¡¾åæ€ä¹‰ï¼Œæ¡çº¹é”ï¼Ÿä¸ºå•¥æ˜¯æ¡çº¹ï¼Œæˆ‘çš„ç†è§£æ˜¯ï¼ŒStripedMapå¸¸å¸¸ç”¨äºåˆ†ç¦»é”çš„ç»“æ„ï¼Œæ¨¡æ¿Tçš„ç±»å‹å¾€å¾€æ˜¯ä¸€ä¸ªé“¾è¡¨ï¼ˆæ¯ä¸ªé“¾è¡¨å…±ç”¨ä¸€ä¸ªé”ï¼‰ï¼Œå¤šä¸ªé“¾è¡¨ç»“æ„çœ‹èµ·æ¥å°±æ¯”è¾ƒåƒæ¡çº¹äº†ï¼Œè„‘æ´ä»…ä¾›å¨±ä¹ã€‚</p>

<h2 id="densemapllvm-densemaph">DenseMap(llvm-DenseMap.h)</h2>

<p>è¿™ä¸ªå®¶ä¼™æ˜¯ç”¨äºå¼•ç”¨è®¡æ•°çš„æ•°æ®ç»“æ„ï¼Œæœ¬è´¨æ˜¯å“ˆå¸Œè¡¨ï¼Œå’Œä¸€èˆ¬å“ˆå¸Œè¡¨ä¸åŒçš„æ˜¯è¡¨çš„ç»„ç»‡æ–¹æ³•å’Œå†²çªå¤„ç†æ–¹å¼ã€‚</p>

<p>ä¸‹é¢ç”¨äºè®°å½•å¯¹è±¡retainCountçš„RefcountMapå°±æ˜¯ä¸€ä¸ªDenseMap.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct SideTable {
    spinlock_t slock;
    RefcountMap refcnts;
    weak_table_t weak_table;
}
</code></pre></div></div>

<p>DenseMapä¸€å¼€å§‹æ˜¯ç”±è°·æ­Œæå‡ºçš„ä¸€ç§å“ˆå¸Œç®—æ³•ï¼ˆå…¶å®æˆ‘æ„Ÿè§‰å¯¹äºå“ˆå¸Œæ¥è¯´æ›´å¤šçš„æ˜¯å†²çªå¤„ç†æ–¹æ³•ï¼‰ï¼Œå¾ˆæƒŠå–œåœ¨è‹¹æœçš„llvmä»£ç ä¸­å¯ä»¥çœ‹åˆ°è‹¹æœçš„å®ç°ã€‚</p>

<p>DenseMapçš„æˆå‘˜å˜é‡æœ‰</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  BucketT *Buckets;
  unsigned NumEntries;
  unsigned NumTombstones;
  unsigned NumBuckets;
</code></pre></div></div>

<p>å…¶ä¸­</p>

<ul>
  <li>BucketT æ˜¯std:pairç»“æ„ï¼Œå¯¹DenseMapæ¥è¯´ï¼Œkeyå°±æ˜¯å“ˆå¸Œé”®å€¼ï¼Œvalueå°±æ˜¯çœŸæ­£è¦å­˜å…¥çš„å¯¹è±¡,è€Œpairçš„å†…å­˜åˆ†å¸ƒè¿ç»­ï¼Œé”®å€¼å¯¹å¾€å¾€åŒæ—¶å­˜åœ¨äºcache lineã€‚</li>
  <li>NumEntries è¡¨æ˜æ¡ç›®ä¸ªæ•°</li>
  <li>NumTombstones è¡¨ç¤ºè¢«åˆ é™¤çš„é”®å€¼å¯¹ä¸ªæ•°</li>
  <li>NumBuckets è¡¨ç¤ºBucketsä¸ªæ•°</li>
</ul>

<p>æ¥ä¸‹æ¥çœ‹çœ‹DenseMapæœ€å…³é”®çš„å†²çªå¤„ç†é€»è¾‘ï¼š
å³</p>

<ul>
  <li>é¦–å…ˆè·å¾—BucketæŒ‡é’ˆå’ŒBucketæ•°</li>
  <li>æ ¹æ®ä¼ å…¥æŒ‡é’ˆè®¡ç®—å“ˆå¸Œå€¼å¹¶ä»¥Bucketæ•°å–æ¨¡çš„åˆ°BucketNo</li>
  <li>å¾ªç¯æŸ¥æ‰¾
    <ol>
      <li>æ ¹æ®BucketNoæ‰¾åˆ°é”®åœ¨Bucketä¸­çš„åç§»ä½ç½®</li>
      <li>å¦‚æœè¯¥åç§»ä½ç½®æœ‰åŒæ ·çš„é”®ï¼Œåˆ™<strong>è¿”å›Bucketå¹¶è®¤ä¸ºæ‰¾åˆ°</strong></li>
      <li>å¦‚æœè¯¥åç§»ä½ç½®æ˜¯ç©ºçš„ï¼Œåˆ™<strong>è¿”å›è¯¥Bucketå¹¶è®¤ä¸ºæ²¡æ‰¾åˆ°</strong></li>
      <li>å¦‚æœè¯¥ä½ç½®æ˜¯ç©ºï¼Œå¹¶ä¸”ä¸Šä¸€æ¬¡æŸ¥åˆ°åˆ°äº†Tombstoneï¼Œåˆ™<strong>è¿”å›Tombstoneä½ç½®</strong></li>
      <li>å¦‚æœè¯¥ä½ç½®æ˜¯ä¸€ä¸ªTombstoneå¹¶ä¸”ä»æœªæ‰¾åˆ°è¿‡Tombstone,åˆ™è®°ä¸‹è¿™ä¸ªä½ç½®</li>
      <li>åˆ°è¿™ä¸€æ­¥è¿˜æ²¡æ‰¾åˆ°ï¼Œåˆ™æŒ‰ç…§ä¾æ¬¡å¢åŠ æŒ‰åºéå†åé¢çš„Bucket(è¿™ä¸ªé€»è¾‘å’ŒGoogleçš„å®ç°ä¸ä¸€è‡´)</li>
    </ol>
  </li>
</ul>

<p>ä»¥ä¸‹ä¸ºæºç </p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>template&lt;typename LookupKeyT&gt;
  bool LookupBucketFor(const LookupKeyT &amp;Val,
                       const BucketT *&amp;FoundBucket) const {
    const BucketT *BucketsPtr = getBuckets();
    const unsigned NumBuckets = getNumBuckets();

    if (NumBuckets == 0) {
      FoundBucket = 0;
      return false;
    }

    // FoundTombstone - Keep track of whether we find a tombstone or zero value while probing.
    const BucketT *FoundTombstone = 0;
    const KeyT EmptyKey = getEmptyKey();
    const KeyT TombstoneKey = getTombstoneKey();
    assert(!KeyInfoT::isEqual(Val, EmptyKey) &amp;&amp;
           !KeyInfoT::isEqual(Val, TombstoneKey) &amp;&amp;
           "Empty/Tombstone value shouldn't be inserted into map!");

    unsigned BucketNo = getHashValue(Val) &amp; (NumBuckets-1);
    unsigned ProbeAmt = 1;
    while (1) {
      const BucketT *ThisBucket = BucketsPtr + BucketNo;
      // Found Val's bucket?  If so, return it.
      if (KeyInfoT::isEqual(Val, ThisBucket-&gt;first)) {
        FoundBucket = ThisBucket;
        return true;
      }

      // If we found an empty bucket, the key doesn't exist in the set.
      // Insert it and return the default value.
      if (KeyInfoT::isEqual(ThisBucket-&gt;first, EmptyKey)) {
        // If we've already seen a tombstone while probing, fill it in instead
        // of the empty bucket we eventually probed to.
        if (FoundTombstone) ThisBucket = FoundTombstone;
        FoundBucket = FoundTombstone ? FoundTombstone : ThisBucket;
        return false;
      }

      // If this is a tombstone, remember it.  If Val ends up not in the map, we
      // prefer to return it than something that would require more probing.
      // Ditto for zero values.
      if (KeyInfoT::isEqual(ThisBucket-&gt;first, TombstoneKey) &amp;&amp; !FoundTombstone)
        FoundTombstone = ThisBucket;  // Remember the first tombstone found.
      if (ZeroValuesArePurgeable  &amp;&amp;
          ThisBucket-&gt;second == 0  &amp;&amp;  !FoundTombstone)
        FoundTombstone = ThisBucket;

      // Otherwise, it's a hash collision or a tombstone, continue quadratic
      // probing.
      if (ProbeAmt &gt; NumBuckets) {
          // No empty buckets in table. Die.
          _objc_fatal("Hash table corrupted. This is probably a memory error "
                      "somewhere. (table at %p, buckets at %p (%zu bytes), "
                      "%u buckets, %u entries, %u tombstones, "
                      "data %p %p %p %p)",
                      this, BucketsPtr, malloc_size(BucketsPtr),
                      NumBuckets, getNumEntries(), getNumTombstones(),
                      ((void**)BucketsPtr)[0], ((void**)BucketsPtr)[1],
                      ((void**)BucketsPtr)[2], ((void**)BucketsPtr)[3]);
      }
      BucketNo += ProbeAmt++;
      BucketNo&amp;= (NumBuckets-1);
    }
  }
</code></pre></div></div>

:ET