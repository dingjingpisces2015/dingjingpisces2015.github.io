---
layout:     post
title:      "Airbnb刷题整理"
date:       2019-05-13 18:58:00
author:     "dingjingpisces"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - 刷题
    - 面试
---



刷题主要参考https://yezizp2012.github.io/2017/06/01/airbnb%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/这篇文章

#Palindrome Pairs
#Round numbers
```
class Solution
{
    func multiply(_ num1: String, _ num2: String) -> String {
        var isNagtive = false
        var num11 = num1
        var num22 = num2
        var ret = "0"
        if num1.hasPrefix("-") {
            isNagtive = true
            num11 = String(num1.suffix(num1.count - 1))
            if num2.hasPrefix("-") {
                isNagtive = false
                num22 = String(num2.suffix(num2.count-1))
            }
        } else if num2.hasPrefix("-") {
            isNagtive = true
            num22 = String(num2.suffix(num2.count-1))
        }
        let base = "0".unicodeScalars.first!.value
        for i in num11 {
            let rangeValue = i.unicodeScalars.first!.value - base
            for _ in 0..<rangeValue {
                ret = add(ret, num22)
            }
            ret.append("0")
        }
        print(ret)
        ret.remove(at: ret.index(before: ret.endIndex))
        if isNagtive == true {
            ret.insert("-", at: ret.startIndex)
        }
        
        return ret
    }
    
    //    func numFromString(_ input:String) ->(String, String) {
    //        let num1range = input.range(of :"num1 = ")
    //        let num2
    //    }
    
    func add(_ a:String, _ b:String) -> String {
        let base = "0".unicodeScalars.first?.value
        let minCount = a.count < b.count ? a.count : b.count
        var ret:String = ""
        var carry:UInt32 = 0
        for i in 0..<minCount
        {
            let va = a[a.index(a.startIndex, offsetBy:a.count-i-1)].unicodeScalars.first!.value - base!
            let vb = b[b.index(b.startIndex, offsetBy: (b.count-i-1))].unicodeScalars.first!.value - base!
            //            print("va = \(va) vb = \(vb) carry = \(carry)")
            let (thisRound, thisCarry) = modAndCarry(va+vb+carry)
            //            print("thisround = \(thisRound), thisCarry = \(thisCarry)")
            ret.append(thisRound)
            carry = thisCarry
        }
        var maxString:String
        if a.count > b.count {
            maxString = a
        } else {
            maxString = b
        }
        for i in minCount..<maxString.count {
            let vc = maxString[maxString.index(maxString.startIndex, offsetBy: maxString.count - i - 1)].unicodeScalars.first!.value - base!
            let (thisRound, thisCarry) = modAndCarry(vc+carry)
            //            print("thisround = \(thisRound), thisCarry = \(thisCarry)")
            ret.append(thisRound)
            carry = thisCarry
        }
        if carry != 0 {
            ret.append(String(carry))
        }
        return String(ret.reversed())
    }
    func modAndCarry(_ input:UInt32) -> (String, UInt32) {
        let last = input % 10
        let carry = (input - last) / 10
        return (String(last), carry)
    }
    func string2num(_ input:String) -> Int64 {
        var ret:Int64 =  0
        for item in input.unicodeScalars {
            ret = ret * 10 + Int64(item.value - 97)
        }
        return ret
    }
}

```

## 字符串拼写问题
text justification
```
class Solution {
    func fullJustify(_ words: [String], _ maxWidth: Int) -> [String] {
        var list = [String]()
        var ret = [String]()
        var count = 0
        for word in words {
            count += word.count
            if count <= maxWidth {
                list.append(word)
                count += 1
            } else {
                ret.append(makeMiddleLine(list, maxWidth))
                list.removeAll()
                count = word.count + 1
                list.append(word)
            }
        }
        ret.append(makeLastLine(list, maxWidth))
        return ret
    }
    
    func makeMiddleLine(_ words: [String], _ maxWidth: Int) -> String {
        var ret = ""
        let wordCount = words.map({$0.count}).reduce(0, +)
        var space = maxWidth - wordCount
        if words.count == 1 {
            ret.append(words.first!)
            let spaceString = String.init(repeating:" ", count: space)
            ret.append(spaceString)
        } else {
            let commonMargin = Int(space / (words.count-1))
            var extraMarginCount = space % (words.count-1)
            let commonSpace = String.init(repeating:" ", count: commonMargin)
            let extraSpace = String.init(repeating:" ", count:commonMargin+1)
            var count = 0
            for word in words {
                ret.append(word)
                if count == words.count - 1 {
                    continue
                } 
                if count < extraMarginCount {
                    ret.append(extraSpace)
                } else {
                    ret.append(commonSpace)
                }
                count += 1
            }
        }
        
        return ret
    }
    func makeLastLine(_ words: [String], _ maxWidth: Int) -> String {
        var ret = ""
        for word in words {
            ret.append(word)
            if ret.count < maxWidth {
                ret.append(" ")
            }
        }
        
        let lastString = String.init(repeating:" ", count:maxWidth-ret.count)
        ret.append(lastString)
        return ret
    }
}
```

## pour water

```
class Solution {
    func run(_ heights:[Int], _ Value:Int, _ K:Int) -> [Int] {
        var ret = [Int]()
        for v in 0..<Value {
            
        }
        
        return ret
    }
    func descirptionWalle(_ heights:[Int], _ waters:[Int]) {
        let height = heights.enumerated().map { (index, element) -> Int in
            return element+waters[index]
        }.max()!
        for h in (0..<height).reversed() {
            var count = 0
            for i in heights {
                if i + waters[count] >= h + 1 && i <= h{
                    print("W", terminator:"")
                } else if i >= h + 1 {
                    print("#", terminator:"")
                } else {
                    print(" ", terminator:"")
                }
                count += 1
            }
            print("")
        }
    }
}

let s = Solution.init().descirptionWalle([2,3,0,5,6],[1,2,1,1,1])

```