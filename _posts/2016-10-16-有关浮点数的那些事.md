#有关浮点数的那些事
##几个小问题
1. 浮点数可以准确表示0吗？ 
2. 浮点数精度为什么是1.19092896-e7
3. 浮点数是否可以判等？
4. 下面两段代码的运行速度如何

```
   const float x = 1.1;
   const float z = 1.111;
   float y = x;
   for(int j = 0; j < 10000000; j++)
   {
       y *= x;
       y /= z;
       y += 0;
       y -= 0;
   }
   return 0;
```

```
   const float x = 1.1;
   const float z = 1.111;
   float y = x;
   for(int j = 0; j < 10000000; j++)
   {
       y *= x;
       y /= z;
       y += 0.1;
       y -= 0.1;
   }
```
本文会从浮点数的表示方法入手回答一下上面的几个问题。
##浮点数的表示方法
IEEE-754对浮点数的定义如下

|Type  | Sign | Actual Exponent | Exp (biased) | Exponent field | Significand (fraction field) | Value |
|:----:|:----:|:---------------:|:------------:|:--------------:|:----------------------------:|:-----------:|
|Zero |0     | −127 |       0         |   0000 0000  |000 0000 0000 0000 0000 0000|  0.0             |
|Negative zero|1|−127|0|0000 0000|000 0000 0000 0000 0000 0000|−0.0|
|One|0|0|127|0111 1111|000 0000 0000 0000 0000 0000|1.0|
|Minus One|1|0|127|0111 1111|000 0000 0000 0000 0000 0000|−1.0|
|Smallest denormalized number|*|−126|0|0000 0000|000 0000 0000 0000 0000 0001|±2−23 × 2−126 = ±2−149 ≈ ±1.4×10−45|
|"Middle" denormalized number|*|−126|0|0000 0000|100 0000 0000 0000 0000 0000|±2−1 × 2−126 = ±2−127 ≈ ±5.88×10−39|
|Largest denormalized number|*|−126|0|0000 0000|111 1111 1111 1111 1111 1111|±(1−2−23) × 2−126 ≈ ±1.18×10−38|
|Smallest normalized number|*|−126|1|0000 0001|000 0000 0000 0000 0000 0000|±2−126 ≈ ±1.18×10−38|
|Largest normalized number|*|127|254|1111 1110|111 1111 1111 1111 1111 1111|±(2−2−23) × 2127 ≈ ±3.4×1038|
|Positive infinity|0|128|255|1111 1111|000 0000 0000 0000 0000 0000|+∞|
|Negative infinity|1|128|255|1111 1111|000 0000 0000 0000 0000 0000|−∞|
|Not a number|*|128|255|1111 1111|non zero|NaN|

* Sign bit can be either 0 or 1 .

从上述定义中可以回答第一个问题：**浮点数可以精确表示0**，用代码验证即

```
float zero1 = 0.0;
float zero2 = 0.0;
if (zero1 == zero2) 
{
	printf(@"zero1 = zero2"); //must setup in if block
}
```

总结**浮点数定义的规律**如下：

* 指数位为00000000时，
	1. 数字位为全0时，若符号位为0，则表示正零0.0 ；若符号位为1时，表示负零-0.0
	2. 数字位不全为零，表示非标浮点数(denormalized number)，此时默认第一位不是1，而是0（标准浮点数为了更大限度的表示数字，认为数字位都是小数点之后的数，并且默认小数点前一位为1）
* 指数位为11111111时，
	1. 数字为全为0时，若符号位为0 ，则表示正无穷，若符号位为1，则表示负无穷
	2. 数字为补全为0，表示这不是一个数NaN
* 因此指数位范围为00000001~11111110 （1~254）
	1. 而为了表示小数部分，指数部分需要减127，因此，指数实际范围为-126~127，标准浮点数指数能表示的范围也就是 2^-126 ~2^127
	
##浮点数的精度
浮点数的精度宏FLT_EPSILON = 1.19092896-e7。
IEEE对FLT_EPSILON的定义为

```
FLT_EPSILON the minimum positive number such that 1.0 + FLT_EPSILON != 1.0.
```

再回到上一章看浮点数，1.0 = 指数位和数字为都为0的数，即

|指数位|数字位|
|:----:|:----:|
|01111111| 000...0000|

而满足上述定义的数只能是在数字位加1的数,即

|指数位|数字位|
|:----:|:----:|
|01111111| 000...000**1**|

表示出来即2<sup>-23</sup> = 1.19092896-e7.

另外，2<sup>-23</sup> 也代表了浮点数类型能够精确表示的最小一位数，我想把这个值作为浮点数的精度也有这方面的考虑。

##浮点数的比较

首先明确一点，所有浮点数的比较都是通过逐一对比比特的方式进行。

因此，两个比特位完全一致，用```==```判断完全可行。
如

```
float a = 0.5;
float b = 0.5;
if (a == b)
{
	printf("isEqual");\\does executed
}
```

然而我们常见的判等往往会经过一系列运算，并且有经验的老司机都不会直接对浮点数判等使用```==```,而是和FLT_EPSILON作对比，即使这样，浮点数在运算中也常常会出现一些和期望值相悖的情况，比如

```
float y = 1000000.3;
float x = 0.3;
float k = 1000000;
float z = y-k-x;
if (fabsf(z) < FLT_EPSILON) {
   NSLog(@"Z < FLT_EPSILON");
}
z = y-x-k;
if (fabsf(z) < FLT_EPSILON) {
    NSLog(@"Z < FLT_EPSILON"); \\only this executed
}
```

直觉上执行```y-k-x```也应该等于0， 但是实际情况却相反，出现这种情况就和浮点数的运算有关。

```y-k-x >= FLT_EPSILON```是因为```y-k```都是数字较大，指数位较高，在运算过程中实施阶数对其操作的时候舍掉了小数位后0.3的精度，因此，计算出的z值实际是0.01+多。

因此，**对于浮点数，比较大小永远是一个伪命题**。

对精度要求不高的地方用一用无妨，关键数据一定要用整数类型.

##非规格化浮点数（Denormalized float）

对于问题4,相信很多同学会认为+/-0 计算量较小，对运算速度影响小，然而实际测试结果却不是。导致低一段代码性能低的原因为，不断地 y*x/z产生了非规格化浮点数， 而在+/-0的情况下，之后的运算都是Denormalized float之间的运算

而第二段代码+/- 0.1 实际上提升了运算阶数，使得运算的数值不是Denormalized float.
 

github 上有个问答http://stackoverflow.com/questions/9314534/why-does-changing-0-1f-to-0-slow-down-performance-by-10x 有人测试过，使用第一段代码性能比第而段代码**慢十倍**。

链接中大牛们的回答正是这个问题的答案，这都是由于CPU对非规格化浮点数的支持导致的。

一般的浮点数，默认数字位从小数点后第一位开始，小数点前一位为1.

而非规格化浮点数为了增加对更小的数字的支持，打破了小数点前一位为1的限制，即将浮点数的表示范围增加了23位（二进制下）。


##结语
关于浮点数的那些事到这结束啦，欢迎大家一起讨论~

